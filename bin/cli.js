#!/usr/bin/env node

import fs from 'fs/promises';
import path from 'path';
import { glob } from 'glob';
import { optimize } from 'svgo';
import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';
import prettier from 'prettier';

// --- Helper Functions ---
function toCamelCase(str) {
  return str.replace(/-(\w)/g, (_, c) => c.toUpperCase());
}

async function formatCode(content, parser = 'babel') {
  try {
    return await prettier.format(content, {
      parser,
      semi: true,
      trailingComma: 'es5',
      singleQuote: true,
      printWidth: 80,
    });
  } catch (e) {
    console.warn('Could not format code. Prettier might be misconfigured.');
    return content;
  }
}

// --- Main Build Function ---
async function buildIcons() {
  console.log('üöÄ Starting icon build process...');

  // 1. Parse CLI arguments
  const argv = yargs(hideBin(process.argv))
    .option('input', {
      alias: 'i',
      describe: 'Directory containing SVG source files',
      type: 'string',
      demandOption: true,
    })
    .option('output', {
      alias: 'o',
      describe: 'Directory to output the generated files',
      type: 'string',
      demandOption: true,
    })
    .option('mode', {
      alias: 'm',
      describe: 'The output mode (a=all, t=treeshakeable, f=full)',
      type: 'string',
      choices: ['all', 'treeshakeable', 'full', 'a', 't', 'f'],
      default: 'all',
    })
    .help().argv;

  const modeAliases = { a: 'all', t: 'treeshakeable', f: 'full' };
  const mode = modeAliases[argv.mode] || argv.mode;

  const inputDir = path.resolve(argv.input);
  const outputDir = path.resolve(argv.output);

  // 2. Clean and create the output directory
  await fs.rm(outputDir, { recursive: true, force: true });
  await fs.mkdir(outputDir, { recursive: true });
  console.log(`‚úÖ Cleaned and created output directory: ${outputDir}`);

  // 3. Find, read, and optimize all SVG files
  const svgFiles = await glob('**/*.svg', { cwd: inputDir });
  if (svgFiles.length === 0) {
    console.warn('‚ö†Ô∏è No SVG files found in the input directory. Exiting.');
    return;
  }

  const svgoOptions = {
    plugins: [
      {
        name: 'preset-default',
        overrides: {
          removeViewBox: false,
        },
      },
      'removeDimensions',
    ],
  };

  const iconData = await Promise.all(
    svgFiles.map(async (file) => {
      const filePath = path.join(inputDir, file);
      const rawContent = await fs.readFile(filePath, 'utf-8');
      const optimizedResult = optimize(rawContent, svgoOptions);
      const iconName = path.basename(file, '.svg');
      const camelCaseName = toCamelCase(iconName);
      return {
        name: iconName,
        camelCaseName,
        svgContent: optimizedResult.data,
      };
    })
  );
  console.log(`‚úÖ Processed ${iconData.length} icons.`);
  console.log(`üì¶ Build mode set to: ${mode}`);

  // 4. Generate file content based on the selected mode
  const filesToWrite = [];
  let indexJsContent = `// Generated by svg-quick`;
  let indexDtsContent = `// Generated by svg-quick`;

  const generateUtilityFunctions = () => {
    const allIconsObjectString = `{${iconData.map((d) => `'${d.camelCaseName}':'${d.svgContent}'`).join(',')}}`;
    const jsContent = `
      export const icons = ${allIconsObjectString};
      export function getIconData(name) { return icons[name]; }
      export function getIconSrc(name) {
        const svgString = getIconData(name);
        if (!svgString) return undefined;
        const base64 = typeof window === 'undefined' ? Buffer.from(svgString).toString('base64') : window.btoa(unescape(encodeURIComponent(svgString)));
        return \`data:image/svg+xml;base64,\${base64}\`;
      }
    `;
    const dtsContent = `
      export declare const icons: Record<string, string>;
      export declare function getIconData(name: string): string | undefined;
      export declare function getIconSrc(name: string): string | undefined;
    `;
    return { jsContent, dtsContent };
  };

  if (mode === 'all' || mode === 'treeshakeable') {
    const iconsJsExports = iconData
      .map((d) => `export const ${d.camelCaseName} = '${d.svgContent}';`)
      .join('\n');
    const iconsDtsExports = iconData
      .map((d) => `export declare const ${d.camelCaseName}: string;`)
      .join('\n');

    const { jsContent: utilityFunctions, dtsContent: utilityFunctionTypes } =
      generateUtilityFunctions();

    const iconsJsContent = `// Tree-shakeable icon exports\n\n${iconsJsExports}\n\n// Utility functions\n${utilityFunctions}`;
    const iconsDtsContent = `// Type definitions for tree-shakeable icons\n\n${iconsDtsExports}\n\n// Utility function types\n${utilityFunctionTypes}`;

    filesToWrite.push({
      name: 'icons.js',
      content: await formatCode(iconsJsContent, 'babel'),
    });
    filesToWrite.push({
      name: 'icons.d.ts',
      content: await formatCode(iconsDtsContent, 'typescript'),
    });
    indexJsContent += `\nexport * from './icons.js';`;
    indexDtsContent += `\nexport * from './icons.js';`;
  }

  if (mode === 'all' || mode === 'full') {
    const { jsContent: helpersJsContent, dtsContent: helpersDtsContent } =
      generateUtilityFunctions();

    filesToWrite.push({
      name: 'helpers.js',
      content: await formatCode(helpersJsContent, 'babel'),
    });
    filesToWrite.push({
      name: 'helpers.d.ts',
      content: await formatCode(helpersDtsContent, 'typescript'),
    });
    indexJsContent += `\nexport * from './helpers.js';`;
    indexDtsContent += `\nexport * from './helpers.js';`;
  }

  // 5. Write all generated files
  filesToWrite.push({
    name: 'index.js',
    content: await formatCode(indexJsContent, 'babel'),
  });
  filesToWrite.push({
    name: 'index.d.ts',
    content: await formatCode(indexDtsContent, 'typescript'),
  });
  await Promise.all(
    filesToWrite.map((file) =>
      fs.writeFile(path.join(outputDir, file.name), file.content, 'utf-8')
    )
  );
  console.log(`‚úÖ ${filesToWrite.length} files written successfully.`);
  console.log('üéâ Build complete! Your icon package is ready.');
}

// --- Run Script ---
buildIcons().catch((error) => {
  console.error('‚ùå An error occurred during the build process:', error);
  process.exit(1);
});
